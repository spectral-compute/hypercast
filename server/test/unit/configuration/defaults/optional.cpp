#include "configuration/defaults.hpp"
#include "configuration/configuration.hpp"

#include "coro_test.hpp"
#include "data.hpp"

#include <map>
#include <set>

/**
 * @file This test checks that all the optional values in the configuration get filled in by default value
 *       initialization.
 *
 * The data file that this relies on it built by the CMake build script.
 */

namespace
{

class OptionalChecker final
{
public:
    /**
     * Check that everything was tested.
     *
     * This test exists because the whole point of this test is to check that default initialization initialized
     * everything it was supposed to, and it would be easy to add a new field to the configuration and forget to add the
     * corresponding test. So the data file used by this is generated by searching the configuration header for
     * std::optional.
     */
    ~OptionalChecker()
    {
        /* Figure out what should have been tested. */
        std::map<std::string, int> expectedNames;
        for (const std::string &name: readFileAsLines(getTestDataPath("srcinfo/optional_config.txt"), false)) {
            if (!expectedNames.contains(name)) {
                expectedNames[name] = 0;
            }
            expectedNames[name]++;
        }

        /* Check that what was tested and what should have been tested match. */
        EXPECT_EQ(expectedNames, names);
    }

    /**
     * Test an optional to see if it's set.
     *
     * @param optional The optional to test.
     * @param name The name of the optional.
     */
    template <typename T>
    void operator()(const std::optional<T> &optional, const std::string &name, bool required = true)
    {
        /* Check that the optional is set to something. */
        if (required) {
            EXPECT_TRUE(optional) << "Optional " << name << " is not set.";
        }

        /* Record that we've tested this. */
        if (!names.contains(name)) {
            names[name] = 0;
        }
        names[name]++;

        /* Make sure we don't accidentally test the same thing twice. */
        EXPECT_FALSE(ptrs.contains(&optional)) << "Optional " << name << " is tested twice.";
        ptrs.insert(&optional);
    }

private:
    std::map<std::string, int> names; ///< Map from field name to number of times we tested that name.
    std::set<const void *> ptrs; ///< Set of things we've already tested.
};

CORO_TEST(ConfigDefaults, Optional, ioc)
{
    /* Fill in defaults for a simple configuration. */
    Config::Root config = {
        .channels = {
            {
                "/live", {
                    .source = {
                        .url = getSmpteDataPath(1920, 1080, 25, 1, 48000).string()
                    }
                }
            }
        }
    };
    co_await fillInDefaults(ioc, config);

    /* Make sure we have a quality to test. */
    EXPECT_EQ(1, config.channels.at("/live").qualities.size());
    if (config.channels.at("/live").qualities.empty()) {
        co_return;
    }
    const Config::Quality &q = config.channels.at("/live").qualities[0];

    /* Check that everything got filled in. */
    OptionalChecker checker;

    checker(config.channels.at("/live").source.latency, "latency");

    checker(q.minInterleaveRate, "minInterleaveRate");
    checker(q.minInterleaveWindow, "minInterleaveWindow");

    checker(q.video.width, "width");
    checker(q.video.height, "height");
    checker(q.video.bitrate, "bitrate");
    checker(q.video.minBitrate, "minBitrate");
    checker(q.video.rateControlBufferLength, "rateControlBufferLength");
    checker(q.video.h26xPreset, "h26xPreset");

    checker(q.audio.sampleRate, "sampleRate", false); // Actually optional, but this test case sets it anyway.

    checker(q.clientBufferControl.minBuffer, "minBuffer");
    checker(q.clientBufferControl.extraBuffer, "extraBuffer");
    checker(q.clientBufferControl.initialBuffer, "initialBuffer");
    checker(q.clientBufferControl.seekBuffer, "seekBuffer");
    checker(q.clientBufferControl.minimumInitTime, "minimumInitTime");

    checker(config.log.print, "print");
}

} // namespace
